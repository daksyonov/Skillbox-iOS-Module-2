# RxSwift: Вступление (конспект)

## Что такое

- Реактивная либа (далее - "библиотека")
- Интегрированная со свифтом
- Предлагает свою модель многопоточности
- Интергрирована со стандартными `Error types`
- Внутри либы - дженерик-обертки
- Абстракция одна - "обозреваемая последовательность"
- Набор sheduler-ов

## Для чего вообще нужен этот фреймворк

Rx *нужен* в следующих контекстах:

- UI вещи - тапы, клики
- Ивенты внутри "домена", будь то воркер или вьюКонтроллер (обновился UI элемент ака датасорс)
- Ивент от "инфраструктуры" (воркер какой-нибудь, вотчер и тому подобное)
- Ивенты интеграции (АПИ, миддлвер итд)
- Разгрузка тяжелых операций на свои потоки, как следствие более плавный UI

## Отличия от `Combine`

- Не огорожен только для куска платформы
- Есть слой взаимодействия с `Cocoa` (`RxCocoa`)
- Есть тесты (`RxTesting`)
- `Combine` не бриджится с `Rx`, а вот наоборот - да

## Error Types

Библиотека не предоставляет дженерик ошибок. Почему? Потому что это не является предметной областью
библиотеки. На композиционном уровне все равно, почему так или иная последовательность данных
профейлилась. Важно пропагировать ошибку дальше по цепи обзерверов.

## Свойства обозреваемых последовательностей

- последовательность завершается за конечное время
- пиарят, что они "никогда"(тм) не выкинет ошибку и будет передавать элементы на:
- main or
- backgoround scheduler
- with refcounted UI (RxCocoa)

## Что может дать библиотека

### Реактивные значения

Насыщает некоторым синтаксическим сахаром, позволяющим:

1. превращать значения в последовательность.
2. обозревать последовательность с помощью нескольких модификаторов
3. трансформировать значения последовательности
1. в том числе через higher-order functions

### UI-байндинги

Тот же самый синтаксис, только если нужно привязаться к последовательности данных, генерируемой
каким-либо `Cocoa` элементом (`UIKit`).
Доступны все операторы `Rx`.

И многое другое…(тм)

## Что к чему

### Обзерваблы ака Посделовательности

Обзервабл это последовательность, эквивалентная таковой в Swift, с возможностью асинхронного
добавления значений и принимающая обзервера в качестве коллбека.
В последовательности может быть 0 или более элементов. Когда последовательность получает ивент
ошибки или завершения, она больше не может "производить" значения.

- любой Обзервабл это просто последовательность
- то есть как `Sequence` в Swift
- но умеет еще асинхронно принимать значения
- [Observable.subscribe][1] === [Sequence.makeIterator][2]
- Обзервер же является коллбеком
- легко представить это все в голове

Пример обзервабл последовательности – движение мышки по экрану. Положение курсора изменится –
появится новая позиция. С течением времени, мышка нагеренит целую "последовательность" таких
позиций.
Это и есть обзервабл последовательность.

> Observed elements over time make a sequence

Rx последовательности описаны с помощью push интерфейса.

### Спин-офф: Push- & Pull-based реактивное программирование

#### Pull

Реактивная система, основанная на pull принципе ожидает реквеста на пуш от всех обзерверов.
Пуш в датастрим происходит, как только источник данных будет "опрошен" всеми обзерверами
на предмет наличия данных.
Для этого испольузется паттерн [Итератор][3] *(проходит по коллекции, будь то граф, список или
дерево, и отслеживает: кол-во пройденных эл-тов, текущ. позицию, кол-во остат. эл-тов. Одна
коллекция может иметь больше одного итератора)*

#### Push

Система же, основанная на push принципе как бы собирает события и после "рассылает" их по
дата-стримам. Здесь дата и апдейты летят к обзерверу от источника. Обзервер здесь
только реагирует на изменения, то есть не блокируется. Это асинхронно (тут бы доказать
но времени нет), поэтому более выгодно для UI-операций, когда важно, чтоб все не фризило.

#### Push + Pull

<https://subscription.packtpub.com/book/application_development/9781788629775/1/ch01lvl1sec14/pull-versus-push-based-reactive-programming>

На самом деле они дополняют друг-друга, т.к. если на одной стороне кто-то пуллит,
то технически на другой стороне кто-то будет пушить.

### Утилизация дата-стрима

Если последовательность завершается в определенное время, дополнительных приседаний с освобождением
не нужны.
Однако если она "бесконечна" (к примеру серия тапов на кнопку), то ресурсы, алокированные на ее
существование будут неосвобождены, пока последовательность существует. В таком случае надо утилизи-
ровать. В этом помогает `dispose` метод, хотя он является "душком".

`DisposeBag` и [`takeUntil`][6] являются эталонными путями утилизации последовательности. Это
применимо в случаях, когда последовательность не завершается вовсе, или же сама по себе не может
определить, в какое время ей завершаться.

## Источники

[1]: https://docs.rxswift.org/protocols/observabletype#/s:7RxSwift14ObservableTypeP9subscribeyAA10Disposable_pqd__AA08ObserverD0Rd__7ElementQyd__AGRtzlF
[2]: https://developer.apple.com/documentation/swift/sequence/2885155-makeiterator
[3]: https://refactoring.guru/ru/design-patterns/iterator
[4]: https://reactivex.io/documentation/operators/takeuntil.html
