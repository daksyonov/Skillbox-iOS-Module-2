//: [Previous](@previous)

// MARK: - Protocol Oriented Programming

/// Напишите, в чём основная идея Protocol Oriented Programming
///
/// Основная идея POP: проектирование интерфейсов начинается с протоколов, решает некоторые проблемы ООП. Описано ниже.
///
/// Какие проблемы ООП решает РОР:
///  - отсутствие множественного наследования (применительно к Swift)
///  - увеличение ответственности при хотя бы одном наследовании:
///  	- все хранимые свойства супер-класса принимаются по дефолту
///  	- ад с инициализаторами (кейс, когда надо проинитить сабкласс вьюКонтроллера, который сделан на XIB и надо избежать required init – думаю это веселье знакомо :))
///  	- не сломать инварианты класса (дополнительные ограничения на функционал, если к примеру, наследование ради части функционала, а инвариант мешает)
///  	- не поломать логикой супер-класса локальные оверрайды
///  	- лишняя логика супер-класса, которая может быть не нужна, при этом выполняться под капотом, и тратить ресурсы
///  	- для того, чтобы выделить интерфейс, приходится писать абстрактный класс
///
/// Что в решение этих проблем предлагает POP:
///  - множественное наследование
///
///  	protocol A: { }
///  	protocol B: { }
///
///  	struct C: A, B (или A & B) { } // соберется
///
///  - уменьшение нагрузки ответственности уже на этапе проектирования протокола:
///  	- множественное наследование позволяет разделять протоколы по "дробным" кускам функционала и реализовывать по мере необходимости
///  	- по дефолту инициализация отсутствует (только если создатель протокола сам не предусмотрит)
///
///  		protocol A: { func makeMagic() -> Magic } // интерфейс без реализации
///
///  		extension A { func makeMagic() -> Magic { Magic.makeSomeMagic() } } // дефолтная реализация
///
///  	- нет инвариантов, которых мы не ожидаем (опять-таки множественное наследование)
///  	- локальные оверрайды не будут сломаны логикой супер-класса, так как протоколы по дефолту не дают реализаций (с оговорками здесь на protocol extensions)
///  	- лишняя логика, выполняемая под капотом отсутствует – протокол ничего не скрывает
///  	- не нужен абстрактный класс, чтобы написать интерфейс

//: [Next](@next)
